{"cells":[{"cell_type":"code","source":"# -*- coding: utf-8 -*-\nfrom odoo import models, fields, api, _\nfrom odoo.exceptions import UserError\nimport base64\nimport csv\nimport io\nimport logging\n\n_logger = logging.getLogger(__name__)\n\nclass EnergyDataSource(models.Model):\n    _name = 'energy.data.source'\n    _description = 'Джерело енергетичних даних'\n    _rec_name = 'name' # Використовувати поле 'name' як назву запису\n\n    data_type = fields.Selection([\n        ('consumption', 'Споживання (кВт)'),\n        ('solar_generation', 'Сонячна генерація (кВт)'),\n        ('gas_price', 'Ціна газу ($/кВт·год)'),\n        ('grid_price', 'Ціна мережі ($/кВт·год)')\n    ], string='Тип даних', required=True, copy=False)\n    name = fields.Char(string='Назва', required=True, copy=False,\n                       default=lambda self: self.env['ir.sequence'].next_by_code('energy.data.source') or _('Новий'))\n    file_name = fields.Char(string='Ім\\'я файлу')\n    file_data = fields.Binary(string='Завантажити CSV файл', required=True)\n    date_uploaded = fields.Datetime(string='Дата завантаження', default=fields.Datetime.now(), readonly=True)\n    notes = fields.Text(string='Примітки')\n\n    # Примітка: Обмеження data_type_unique видалено з __manifest__.py, щоб дозволити завантажувати кілька файлів одного типу.\n    # Якщо потрібно лише по одному файлу кожного типу, розкоментуйте:\n    # _sql_constraints = [\n    #     ('data_type_unique', 'unique(data_type)', 'Дозволено лише один запис для кожного типу даних!'),\n    # ]\n\n    @api.constrains('file_data')\n    def _check_file_data(self):\n        for record in self:\n            if not record.file_data:\n                raise UserError(_(\"Файл для завантаження не може бути порожнім.\"))\n\n    def action_import_data(self):\n        \"\"\"\n        Імпортує дані з завантаженого CSV-файлу у відповідну модель.\n        Очікуваний формат CSV: \"Hour,Value\" (без заголовка або з заголовком, який буде пропущено).\n        \"\"\"\n        self.ensure_one() # Переконатися, що метод викликається для одного запису\n        if not self.file_data:\n            raise UserError(_(\"Немає завантаженого файлу для імпорту.\"))\n\n        try:\n            # Декодуємо дані файлу з base64\n            decoded_data = base64.b64decode(self.file_data).decode('utf-8')\n            # Використовуємо io.StringIO для обробки рядка як файлу\n            data_file = io.StringIO(decoded_data)\n            csv_reader = csv.reader(data_file)\n            \n            # Пропускаємо рядок заголовка, якщо він є.\n            # Якщо ваш CSV не має заголовка, ви можете закоментувати наступний рядок.\n            try:\n                header = next(csv_reader) \n                if not (len(header) >= 2 and (header[0].strip().lower() == 'hour' or header[1].strip().lower() == 'value')):\n                    # Якщо заголовок не відповідає очікуваному, можливо, це перший рядок даних.\n                    # Повертаємося до початку файлу і не пропускаємо заголовок.\n                    data_file.seek(0)\n                    csv_reader = csv.reader(data_file)\n            except StopIteration:\n                # Файл порожній або містить лише заголовок\n                raise UserError(_(\"Завантажений CSV-файл порожній або не містить даних.\"))\n\n\n            if self.data_type == 'consumption':\n                self._import_hourly_data(csv_reader, 'energy.consumption.data')\n            elif self.data_type == 'solar_generation':\n                self._import_hourly_data(csv_reader, 'energy.solar.data')\n            elif self.data_type == 'gas_price':\n                self._import_hourly_data(csv_reader, 'energy.gas.price')\n            elif self.data_type == 'grid_price':\n                self._import_hourly_data(csv_reader, 'energy.grid.price')\n\n            self.message_post(body=_(\"Дані успішно імпортовано для %s.\") % self.data_type)\n        except Exception as e:\n            _logger.error(\"Помилка під час імпорту даних: %s\", str(e))\n            raise UserError(_(\"Помилка під час імпорту даних: %s. Перевірте формат CSV (Hour,Value) та вміст.\") % str(e))\n\n    def _import_hourly_data(self, csv_reader, model_name):\n        \"\"\"\n        Допоміжна функція для імпорту погодинних даних у вказану модель.\n        \"\"\"\n        # Очищаємо існуючі дані, пов'язані з цим джерелом, щоб уникнути дублювання\n        self.env[model_name].search([('data_source_id', '=', self.id)]).unlink() \n        records_to_create = []\n        for i, row in enumerate(csv_reader):\n            if not row or len(row) < 2:\n                _logger.warning(\"Пропущено рядок %s через невірний формат: %s\", i + 1, row)\n                continue # Пропускаємо порожні або неповні рядки\n            try:\n                hour = int(row[0].strip())\n                value = float(row[1].strip())\n                if not (1 <= hour <= 8760):\n                    raise ValueError(\"Година повинна бути в діапазоні від 1 до 8760.\")\n                records_to_create.append({\n                    'hour': hour,\n                    'value': value,\n                    'data_source_id': self.id,\n                })\n            except ValueError as ve:\n                self.env.cr.rollback() # Відкат у разі помилки\n                raise UserError(_(\"Невірне числове значення або формат години/значення в рядку %s: %s. Помилка: %s\") % (i + 2, row, str(ve)))\n            except Exception as ex:\n                self.env.cr.rollback()\n                raise UserError(_(\"Неочікувана помилка в рядку %s: %s. Помилка: %s\") % (i + 2, row, str(ex)))\n        \n        if records_to_create:\n            # Створюємо записи пакетом для кращої продуктивності\n            self.env[model_name].create(records_to_create)\n        else:\n            raise UserError(_(\"Немає даних для імпорту після обробки файлу. Перевірте вміст CSV.\"))\n\n# Модель для погодинних даних споживання\nclass EnergyConsumptionData(models.Model):\n    _name = 'energy.consumption.data'\n    _description = 'Погодинні дані споживання енергії'\n\n    data_source_id = fields.Many2one('energy.data.source', string='Джерело даних', required=True, ondelete='cascade')\n    hour = fields.Integer(string='Година (1-8760)', required=True)\n    value = fields.Float(string='Споживання (кВт)', required=True)\n\n    _sql_constraints = [\n        ('hour_unique_consumption', 'unique(data_source_id, hour)', 'Година повинна бути унікальною для кожного джерела споживання!'),\n    ]\n\n# Модель для погодинних даних сонячної генерації\nclass EnergySolarData(models.Model):\n    _name = 'energy.solar.data'\n    _description = 'Погодинні дані сонячної генерації'\n\n    data_source_id = fields.Many2one('energy.data.source', string='Джерело даних', required=True, ondelete='cascade')\n    hour = fields.Integer(string='Година (1-8760)', required=True)\n    value = fields.Float(string='Сонячна генерація (кВт)', required=True)\n\n    _sql_constraints = [\n        ('hour_unique_solar', 'unique(data_source_id, hour)', 'Година повинна бути унікальною для кожного джерела сонячної генерації!'),\n    ]\n\n# Модель для погодинних даних ціни на газ\nclass EnergyGasPrice(models.Model):\n    _name = 'energy.gas.price'\n    _description = 'Погодинні дані ціни на газ'\n\n    data_source_id = fields.Many2one('energy.data.source', string='Джерело даних', required=True, ondelete='cascade')\n    hour = fields.Integer(string='Година (1-8760)', required=True)\n    value = fields.Float(string='Ціна газу ($/кВт·год)', required=True)\n\n    _sql_constraints = [\n        ('hour_unique_gas', 'unique(data_source_id, hour)', 'Година повинна бути унікальною для кожного джерела ціни на газ!'),\n    ]\n\n# Модель для погодинних даних ціни з мережі\nclass EnergyGridPrice(models.Model):\n    _name = 'energy.grid.price'\n    _description = 'Погодинні дані ціни з мережі'\n\n    data_source_id = fields.Many2one('energy.data.source', string='Джерело даних', required=True, ondelete='cascade')\n    hour = fields.Integer(string='Година (1-8760)', required=True)\n    value = fields.Float(string='Ціна мережі ($/кВт·год)', required=True)\n\n    _sql_constraints = [\n        ('hour_unique_grid', 'unique(data_source_id, hour)', 'Година повинна бути унікальною для кожного джерела ціни мережі!'),\n    ]\n\n# Модель для параметрів акумуляторної батареї\nclass EnergyBatteryParams(models.Model):\n    _name = 'energy.battery.params'\n    _description = 'Параметри акумуляторної батареї'\n    _rec_name = 'name'\n\n    name = fields.Char(string='Назва', required=True, default='Параметри батареї за замовчуванням')\n    capacity_kwh = fields.Float(string='Ємність (кВт·год)', default=100.0, required=True, help=\"Максимальна ємність батареї в кВт·год.\")\n    max_charge_kw = fields.Float(string='Макс. потужність заряду (кВт)', default=50.0, required=True, help=\"Максимальна потужність, з якою батарея може заряджатися.\")\n    max_discharge_kw = fields.Float(string='Макс. потужність розряду (кВт)', default=50.0, required=True, help=\"Максимальна потужність, з якою батарея може розряджатися.\")\n    charge_efficiency = fields.Float(string='ККД заряду (%)', default=95.0, required=True, help=\"Ефективність перетворення енергії при заряді батареї.\")\n    discharge_efficiency = fields.Float(string='ККД розряду (%)', default=95.0, required=True, help=\"Ефективність перетворення енергії при розряді батареї.\")\n    initial_soc_kwh = fields.Float(string='Початковий SoC (кВт·год)', default=50.0, required=True, help=\"Початковий стан заряду батареї на початок періоду оптимізації.\")\n    \n    _sql_constraints = [\n        ('name_unique', 'unique(name)', 'Назва параметрів батареї повинна бути унікальною!'),\n    ]\n\n# Додаємо One2many зв'язки до EnergyDataSource (це потрібно робити після визначення дочірніх моделей)\n# Ці поля не є обов'язковими для функціоналу, але зручні для перегляду даних\nEnergyDataSource.energy_consumption_data_ids = fields.One2many('energy.consumption.data', 'data_source_id', string='Записи даних споживання')\nEnergyDataSource.energy_solar_data_ids = fields.One2many('energy.solar.data', 'data_source_id', string='Записи даних сонячної генерації')\nEnergyDataSource.energy_gas_price_ids = fields.One2many('energy.gas.price', 'data_source_id', string='Записи даних ціни на газ')\nEnergyDataSource.energy_grid_price_ids = fields.One2many('energy.grid.price', 'data_source_id', string='Записи даних ціни мережі')","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}