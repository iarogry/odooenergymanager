{"cells":[{"cell_type":"code","source":"# -*- coding: utf-8 -*-\nfrom odoo import models, fields, api, _\nfrom odoo.exceptions import UserError\nimport pandas as pd\nfrom pulp import * # Бібліотека для лінійного програмування\nimport logging\n\n_logger = logging.getLogger(__name__)\n\nclass EnergyOptimizationRun(models.Model):\n    _name = 'energy.optimization.run'\n    _description = 'Запуск оптимізації енергії'\n    _inherit = ['mail.thread', 'mail.activity.mixin'] # Для функцій чату та відстеження активності\n\n    name = fields.Char(string='Назва запуску', required=True, copy=False,\n                       default=lambda self: self.env['ir.sequence'].next_by_code('energy.optimization.run') or _('Новий'))\n    run_datetime = fields.Datetime(string='Дата/час запуску', default=fields.Datetime.now(), readonly=True)\n    state = fields.Selection([\n        ('draft', 'Чернетка'),\n        ('running', 'Виконується'),\n        ('completed', 'Завершено'),\n        ('failed', 'Помилка')\n    ], string='Статус', default='draft', readonly=True, tracking=True)\n    total_cost = fields.Float(string='Загальна оптимізована вартість ($)', readonly=True, tracking=True)\n    notes = fields.Text(string='Примітки')\n\n    # Параметри з пов'язаних моделей (вхідні дані)\n    consumption_source_id = fields.Many2one('energy.data.source', string='Дані споживання', domain=[('data_type', '=', 'consumption')], required=True)\n    solar_source_id = fields.Many2one('energy.data.source', string='Дані сонячної генерації', domain=[('data_type', '=', 'solar_generation')], required=True)\n    gas_price_source_id = fields.Many2one('energy.data.source', string='Дані ціни на газ', domain=[('data_type', '=', 'gas_price')], required=True)\n    grid_price_source_id = fields.Many2one('energy.data.source', string='Дані ціни мережі', domain=[('data_type', '=', 'grid_price')], required=True)\n    \n    battery_params_id = fields.Many2one('energy.battery.params', string='Параметри батареї', required=True)\n\n    # Загальні параметри генератора на газі\n    gas_generator_min_power_kw = fields.Float(string='Мін. потужність газ. ген. (кВт)', default=0.0, help=\"Мінімальна потужність, яку може видавати газовий генератор.\")\n    gas_generator_max_power_kw = fields.Float(string='Макс. потужність газ. ген. (кВт)', default=100.0, help=\"Максимальна потужність, яку може видавати газовий генератор.\")\n    gas_generator_efficiency = fields.Float(string='ККД газ. ген. (%)', default=35.0, help=\"Коефіцієнт корисної дії газового генератора для перерахунку ціни газу в ціну електроенергії.\")\n\n    # Результати оптимізації (One2many зв'язок з погодинними результатами)\n    optimization_lines = fields.One2many('energy.optimization.line', 'optimization_run_id', string='Результати оптимізації', readonly=True)\n\n    _sql_constraints = [\n        ('name_unique', 'unique(name)', 'Назва запуску повинна бути унікальною!'),\n    ]\n\n    def action_run_optimization(self):\n        \"\"\"\n        Запускає процес оптимізації енергетичного міксу.\n        \"\"\"\n        self.ensure_one()\n        self.state = 'running'\n        self.message_post(body=_(\"Оптимізація розпочата.\"))\n        self.env.cr.commit() # Зберігаємо зміну статусу негайно\n\n        try:\n            # 1. Отримуємо всі необхідні дані з Odoo\n            consumption_data = {d.hour: d.value for d in self.consumption_source_id.energy_consumption_data_ids}\n            solar_data = {d.hour: d.value for d in self.solar_source_id.energy_solar_data_ids}\n            gas_price_data = {d.hour: d.value for d in self.gas_price_source_id.energy_gas_price_ids}\n            grid_price_data = {d.hour: d.value for d in self.grid_price_source_id.energy_grid_price_ids}\n\n            battery_params = self.battery_params_id\n\n            # Перевіряємо, чи всі дані охоплюють повний рік (8760 годин)\n            hours = range(1, 8761)\n            if not (len(consumption_data) == 8760 and len(solar_data) == 8760 and \n                    len(gas_price_data) == 8760 and len(grid_price_data) == 8760):\n                 raise UserError(_(\"Дані для всіх джерел повинні охоплювати рівно 8760 годин.\"))\n\n            # 2. Готуємо дані для PuLP за допомогою pandas DataFrame\n            df = pd.DataFrame(index=hours)\n            df['Consumption_kW'] = [consumption_data.get(h, 0.0) for h in hours]\n            df['Solar_Available_kW'] = [solar_data.get(h, 0.0) for h in hours]\n            \n            # Перераховуємо ціну газу у вартість електроенергії з генератора\n            # Price_per_kWh = Gas_Price_per_kWh / (Gas_Generator_Efficiency / 100)\n            if self.gas_generator_efficiency == 0:\n                raise UserError(_(\"ККД газового генератора не може бути нульовим.\"))\n            df['Gas_Gen_Cost_per_kWh'] = [price / (self.gas_generator_efficiency / 100) for price in gas_price_data.values()]\n            \n            df['Grid_Price_per_kWh'] = [grid_price_data.get(h, 0.0) for h in hours]\n\n            # 3. Визначаємо модель оптимізації PuLP\n            model = LpProblem(\"Оптимізація_Енергетичного_Міксу\", LpMinimize)\n\n            # Змінні рішення\n            P_solar = LpVariable.dicts(\"P_solar\", hours, lowBound=0) # Потужність від сонячної системи\n            P_grid = LpVariable.dicts(\"P_grid\", hours, lowBound=0) # Потужність з мережі\n            P_gen = LpVariable.dicts(\"P_gen\", hours, lowBound=0) # Потужність від газового генератора\n            P_batt_charge = LpVariable.dicts(\"P_batt_charge\", hours, lowBound=0, upBound=battery_params.max_charge_kw) # Потужність заряду батареї\n            P_batt_discharge = LpVariable.dicts(\"P_batt_discharge\", hours, lowBound=0, upBound=battery_params.max_discharge_kw) # Потужність розряду батареї\n            E_batt = LpVariable.dicts(\"E_batt\", hours, lowBound=0, upBound=battery_params.capacity_kwh) # Енергія в батареї\n\n            # Цільова функція: Мінімізувати загальну вартість\n            # Сонячна енергія має 0 операційних витрат, тому не включається в цільову функцію.\n            # Вартість деградації батареї тут не враховується для простоти, але може бути додана.\n            model += lpSum(P_grid[t] * df.loc[t, 'Grid_Price_per_kWh'] +\n                           P_gen[t] * df.loc[t, 'Gas_Gen_Cost_per_kWh']\n                           for t in hours), \"Загальна_Вартість\"\n\n            # Обмеження\n            for t in hours:\n                # 1. Баланс потужності: Споживання повинно бути покрите\n                model += (df.loc[t, 'Consumption_kW'] == P_solar[t] + P_grid[t] + P_gen[t] + P_batt_discharge[t] - P_batt_charge[t]), f\"Баланс_Потужності_{t}\"\n\n                # 2. Обмеження сонячної генерації: Не більше доступної сонячної енергії\n                model += (P_solar[t] <= df.loc[t, 'Solar_Available_kW']), f\"Обмеження_Сонячної_Генерації_{t}\"\n\n                # 3. Обмеження газового генератора\n                model += (self.gas_generator_min_power_kw <= P_gen[t]), f\"Ген_Мін_Потужність_{t}\"\n                model += (P_gen[t] <= self.gas_generator_max_power_kw), f\"Ген_Макс_Потужність_{t}\"\n\n                # 4. Динаміка та обмеження батареї\n                if t == 1: # Початковий стан заряду батареї\n                    model += (E_batt[t] == battery_params.initial_soc_kwh + \n                               (P_batt_charge[t] * (battery_params.charge_efficiency / 100)) - \n                               (P_batt_discharge[t] / (battery_params.discharge_efficiency / 100))), f\"Батарея_Початковий_Стан_{t}\"\n                else: # Динаміка стану заряду для наступних годин\n                    model += (E_batt[t] == E_batt[t-1] + \n                               (P_batt_charge[t] * (battery_params.charge_efficiency / 100)) - \n                               (P_batt_discharge[t] / (battery_params.discharge_efficiency / 100))), f\"Батарея_Стан_{t}\"\n                \n                # Обмеження, що батарея не може одночасно заряджатися і розряджатися\n                # Для LP це може бути неявно, але для більш суворих моделей MILP потрібні бінарні змінні.\n                # У PuLP, якщо не вказано MILP, оптимізатор природно вибере найдешевший варіант.\n                # Якщо P_batt_charge[t] і P_batt_discharge[t] обидва > 0, це означає, що може бути арбітраж,\n                # але з реалістичними ефективностями та цінами, це рідко відбувається.\n                # Для строгого \"або-або\" потрібні бінарні змінні (MILP):\n                # is_charging = LpVariable(f\"is_charging_{t}\", cat='Binary')\n                # is_discharging = LpVariable(f\"is_discharging_{t}\", cat='Binary')\n                # model += P_batt_charge[t] <= battery_params.max_charge_kw * is_charging\n                # model += P_batt_discharge[t] <= battery_params.max_discharge_kw * is_discharging\n                # model += is_charging + is_discharging <= 1\n\n            # 4. Вирішуємо модель\n            solver = PULP_CBC_CMD(msg=0, timeLimit=3600) # Використовуємо CBC солвер, ліміт часу 1 година\n            model.solve(solver)\n\n            if LpStatus[model.status] == 'Optimal':\n                self.total_cost = value(model.objective)\n                self.state = 'completed'\n                self.message_post(body=_(\"Оптимізація успішно завершена! Загальна вартість: %s $\") % round(self.total_cost, 2))\n\n                # 5. Зберігаємо результати погодинно\n                self.optimization_lines.unlink() # Очищаємо попередні результати\n                lines_to_create = []\n                for t in hours:\n                    lines_to_create.append({\n                        'optimization_run_id': self.id,\n                        'hour': t,\n                        'consumption_kw': df.loc[t, 'Consumption_kW'],\n                        'solar_kw': value(P_solar[t]),\n                        'grid_kw': value(P_grid[t]),\n                        'gas_gen_kw': value(P_gen[t]),\n                        'battery_charge_kw': value(P_batt_charge[t]),\n                        'battery_discharge_kw': value(P_batt_discharge[t]),\n                        'battery_soc_kwh': value(E_batt[t]),\n                    })\n                # Створюємо записи пакетом для продуктивності\n                self.env['energy.optimization.line'].create(lines_to_create)\n\n            else:\n                self.state = 'failed'\n                self.total_cost = 0.0\n                self.message_post(body=_(\"Оптимізація не змогла знайти оптимальне рішення. Статус: %s\") % LpStatus[model.status])\n                _logger.error(\"Оптимізація не змогла знайти оптимальне рішення. Статус: %s\", LpStatus[model.status])\n\n        except Exception as e:\n            self.state = 'failed'\n            self.total_cost = 0.0\n            self.message_post(body=_(\"Під час оптимізації сталася помилка: %s\") % str(e))\n            _logger.error(\"Помилка під час оптимізації енергії: %s\", str(e), exc_info=True)\n\n# Модель для зберігання погодинних результатів оптимізації\nclass EnergyOptimizationLine(models.Model):\n    _name = 'energy.optimization.line'\n    _description = 'Погодинний результат оптимізації енергії'\n\n    optimization_run_id = fields.Many2one('energy.optimization.run', string='Запуск оптимізації', required=True, ondelete='cascade')\n    hour = fields.Integer(string='Година', required=True)\n    consumption_kw = fields.Float(string='Споживання (кВт)', readonly=True)\n    solar_kw = fields.Float(string='Сонячна (кВт)', readonly=True)\n    grid_kw = fields.Float(string='Мережа (кВт)', readonly=True)\n    gas_gen_kw = fields.Float(string='Газ. ген. (кВт)', readonly=True)\n    battery_charge_kw = fields.Float(string='Заряд батареї (кВт)', readonly=True)\n    battery_discharge_kw = fields.Float(string='Розряд батареї (кВт)', readonly=True)\n    battery_soc_kwh = fields.Float(string='SoC батареї (кВт·год)', readonly=True) # State of Charge\n\n    _sql_constraints = [\n        ('optimization_hour_unique', 'unique(optimization_run_id, hour)', 'Година повинна бути унікальною для кожного запуску оптимізації!'),\n    ]","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}